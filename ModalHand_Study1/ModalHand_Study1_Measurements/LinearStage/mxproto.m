function [methodinfo,structs,enuminfo,ThunkLibName]=mxproto
%MXPROTO Create structures to define interfaces found in 'PerformaxCom'.

%This function was generated by loadlibrary.m parser version  on Wed Nov 30 10:57:38 2022
%perl options:'PerformaxCom.i -outfile=mxproto.m -thunkfile=PerformaxCom_thunk_pcwin64.c -header=PerformaxCom.h'
ival={cell(1,0)}; % change 0 to the actual number of functions to preallocate the data.
structs=[];enuminfo=[];fcnNum=1;
fcns=struct('name',ival,'calltype',ival,'LHS',ival,'RHS',ival,'alias',ival,'thunkname', ival);
MfilePath=fileparts(mfilename('fullpath'));
ThunkLibName=fullfile(MfilePath,'PerformaxCom_thunk_pcwin64');
% extern  int nPerformaxCom ; 
fcns.name{fcnNum}='nPerformaxCom'; fcns.calltype{fcnNum}='data'; fcns.LHS{fcnNum}='int32Ptr'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
%  int fnPerformaxCom ( void ); 
fcns.thunkname{fcnNum}='int32voidThunk';fcns.name{fcnNum}='fnPerformaxCom'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
% BOOL  _stdcall  fnPerformaxComFlush ( HANDLE pHandle ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='fnPerformaxComFlush'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
% BOOL  _stdcall  fnPerformaxComGetNumDevices ( LPDWORD lpNumDevices ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='fnPerformaxComGetNumDevices'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'uint32Ptr'};fcnNum=fcnNum+1;
% BOOL  _stdcall  fnPerformaxComGetProductString ( DWORD dwNumDevices , LPVOID lpDeviceString , DWORD dwOptions ); 
fcns.thunkname{fcnNum}='int32ulongvoidPtrulongThunk';fcns.name{fcnNum}='fnPerformaxComGetProductString'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'ulong', 'voidPtr', 'ulong'};fcnNum=fcnNum+1;
% BOOL  _stdcall  fnPerformaxComOpen ( DWORD dwDeviceNum , HANDLE * pHandle ); 
fcns.thunkname{fcnNum}='int32ulongvoidPtrThunk';fcns.name{fcnNum}='fnPerformaxComOpen'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'ulong', 'voidPtrPtr'};fcnNum=fcnNum+1;
% BOOL  _stdcall  fnPerformaxComClose ( HANDLE pHandle ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='fnPerformaxComClose'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
% BOOL  _stdcall  fnPerformaxComSetTimeouts ( DWORD dwReadTimeout , DWORD dwWriteTimeout ); 
fcns.thunkname{fcnNum}='int32ulongulongThunk';fcns.name{fcnNum}='fnPerformaxComSetTimeouts'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'ulong', 'ulong'};fcnNum=fcnNum+1;
% BOOL  _stdcall  fnPerformaxComSendRecv ( HANDLE pHandle , LPVOID wBuffer , DWORD dwNumBytesToWrite , DWORD dwNumBytesToRead , LPVOID rBuffer ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrulongulongvoidPtrThunk';fcns.name{fcnNum}='fnPerformaxComSendRecv'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'voidPtr', 'ulong', 'ulong', 'voidPtr'};fcnNum=fcnNum+1;
methodinfo=fcns;